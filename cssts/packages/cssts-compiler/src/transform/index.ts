/**
 * CssTs 转换模块
 * 
 * 提供 .cssts 文件的完整转换功能
 */

import { CssTsParser } from '../parser/index.js'
import { CssTsCstToAst } from '../factory/index.js'
import { 
  getCssClassName, 
  getCssProperty, 
  getCssValue,
  camelToKebab,
  CSSTS_CONFIG
} from '../utils/cssClassName.js'
import { type PseudoUtilsConfig } from '../generator/config.js'
import SlimeGenerator from 'slime-generator/src/SlimeGenerator.ts'

// ==================== 类型定义 ====================

/**
 * 解析后的样式信息
 */
export interface ParsedStyleInfo {
  baseName: string    // 基础名称（原子类名或伪类基础类名）
  pseudos: string[]   // 伪类列表（普通原子类为空数组）
}

/**
 * 转换上下文（用于多文件聚合）
 */
export interface TransformContext {
  styles: Set<string>  // 存储所有样式名（原子类 + 伪类样式）
}

/**
 * 转换结果
 */
export interface TransformResult {
  code: string
  hasStyles: boolean
}

// ==================== 样式名解析 ====================

/**
 * 解析样式名
 * 
 * @example
 * parseStyleName('displayFlex')              // { baseName: 'displayFlex', pseudos: [] }
 * parseStyleName('clickable$$hover$$active') // { baseName: 'clickable', pseudos: ['hover', 'active'] }
 */
export function parseStyleName(name: string): ParsedStyleInfo {
  const parts = name.split(CSSTS_CONFIG.PSEUDO_SEPARATOR)
  return {
    baseName: parts[0],
    pseudos: parts.slice(1)
  }
}

/**
 * 判断是否是伪类样式
 */
export function hasPseudos(name: string): boolean {
  return name.includes(CSSTS_CONFIG.PSEUDO_SEPARATOR)
}

// ==================== 核心转换 ====================

/**
 * 转换 .cssts 文件
 * 
 * @param code - 源代码
 * @param context - 转换上下文（用于写入 styles）
 * @returns 转换结果
 */
export function transformCssTs(code: string, context: TransformContext): TransformResult {
  const parser = new CssTsParser(code)
  const cst = parser.Program()
  const transformer = new CssTsCstToAst()
  const ast = transformer.toProgram(cst)
  
  // 收集使用的样式（原子类 + 伪类样式，直接写入 context）
  // 注：伪类样式（如 clickable$$hover$$active）在 CssTsCstToAst 中已自动收集
  const localUsedAtoms = transformer.getUsedAtoms()
  for (const atom of localUsedAtoms) {
    context.styles.add(atom)
  }
  
  // 生成代码
  const tokens = parser.parsedTokens
  const result = SlimeGenerator.generator(ast, tokens)
  
  return { 
    code: result.code, 
    hasStyles: localUsedAtoms.size > 0 
  }
}

// ==================== CSS 生成 ====================

/**
 * 生成单条原子类 CSS 规则
 */
function generateAtomCssRule(atomName: string, prefix: string = ''): string | null {
  const className = getCssClassName(atomName)
  const property = getCssProperty(atomName)
  const value = getCssValue(atomName)
  if (!property || !value) return null
  const fullClassName = prefix ? `${prefix}${className}` : className
  return `.${fullClassName} { ${property}: ${value}; }`
}

/**
 * 生成伪类 CSS 规则
 */
function generatePseudoCssRule(
  className: string,
  pseudo: string,
  pseudoConfig: Record<string, string> | Record<string, string>[],
  prefix: string = ''
): string {
  const fullClassName = prefix ? `${prefix}${className}` : className
  const configs = Array.isArray(pseudoConfig) ? pseudoConfig : [pseudoConfig]
  const props = configs
    .flatMap(config => Object.entries(config))
    .map(([prop, val]) => `${prop}: ${val}`)
    .join('; ')
  return `.${fullClassName}:${pseudo} { ${props}; }`
}

/**
 * 生成所有 CSS（原子类 + 伪类样式）
 */
export function generateStylesCss(
  styles: Set<string>,
  pseudoUtils: PseudoUtilsConfig | undefined,
  prefix: string = ''
): string {
  const lines: string[] = ['/* Auto-generated by cssts-compiler */', '']
  
  // 分离原子类和伪类样式
  const atomStyles: string[] = []
  const pseudoStyles: Array<{ baseName: string; pseudos: string[] }> = []
  
  for (const name of styles) {
    const parsed = parseStyleName(name)
    if (parsed.pseudos.length > 0) {
      pseudoStyles.push(parsed)
    } else {
      atomStyles.push(name)
    }
  }
  
  // 1. 生成原子类 CSS（按属性分组）
  const grouped = new Map<string, string[]>()
  for (const atomName of atomStyles) {
    const rule = generateAtomCssRule(atomName, prefix)
    if (rule) {
      const property = getCssProperty(atomName) || 'other'
      if (!grouped.has(property)) grouped.set(property, [])
      grouped.get(property)!.push(rule)
    }
  }
  
  for (const property of [...grouped.keys()].sort()) {
    lines.push(`/* ${property} */`)
    lines.push(...grouped.get(property)!.sort())
    lines.push('')
  }
  
  // 2. 生成伪类 CSS（如果有配置）
  if (pseudoUtils && pseudoStyles.length > 0) {
    lines.push('/* $$ Pseudo-class styles */')
    for (const { baseName, pseudos } of pseudoStyles) {
      const className = camelToKebab(baseName)
      for (const pseudo of pseudos) {
        const pseudoConfig = pseudoUtils[pseudo]
        if (pseudoConfig) {
          const rule = generatePseudoCssRule(className, pseudo, pseudoConfig, prefix)
          lines.push(rule)
        }
      }
    }
    lines.push('')
  }
  
  return lines.join('\n')
}

/**
 * 生成 csstsAtom 虚拟模块内容
 */
export function generateCsstsAtomModule(
  styles: Set<string>,
  prefix: string = ''
): string {
  const lines: string[] = [
    '// Auto-generated by cssts-compiler',
    '',
    'export const csstsAtom = {',
  ]
  
  const entries: string[] = []
  const sortedStyles = [...styles].sort()
  
  for (const name of sortedStyles) {
    const parsed = parseStyleName(name)
    
    if (parsed.pseudos.length > 0) {
      // 伪类样式：使用 kebab-case 的基础类名
      const className = camelToKebab(parsed.baseName)
      const fullClassName = prefix ? `${prefix}${className}` : className
      entries.push(`  '${name}': { '${fullClassName}': true }`)
    } else {
      // 普通原子类
      const className = getCssClassName(name)
      const fullClassName = prefix ? `${prefix}${className}` : className
      entries.push(`  ${name}: { '${fullClassName}': true }`)
    }
  }
  
  lines.push(entries.join(',\n'))
  lines.push('}', '', 'export default csstsAtom', '')
  return lines.join('\n')
}

// 兼容旧 API（已废弃，将在下个版本移除）
/** @deprecated 使用 generateStylesCss 代替 */
export const generateUsedAtomsCss = generateStylesCss
