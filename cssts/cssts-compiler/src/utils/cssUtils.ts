import type { CssStyleInfo } from '../factory/CssTsCstToAst.ts'

/**
 * 驼峰命名转 kebab-case
 */
export function camelToKebab(str: string, prefix: string = ''): string {
  const kebab = str
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .replace(/([a-zA-Z])(\d)/g, '$1-$2')
    .toLowerCase()
  return prefix + kebab
}

/**
 * kebab-case 转驼峰
 */
export function kebabToCamel(str: string): string {
  return str.replace(/-([a-z0-9])/g, (_, char) => char.toUpperCase())
}

/**
 * 递归收集所有原子 CSS class
 */
export function collectAllCssClasses(
  styleName: string,
  styles: Map<string, CssStyleInfo>,
  visited: Set<string> = new Set(),
  prefix: string = ''
): string[] {
  if (visited.has(styleName)) {
    console.warn(`Circular reference detected: ${styleName}`)
    return []
  }
  visited.add(styleName)

  const style = styles.get(styleName)
  if (!style) {
    return [camelToKebab(styleName, prefix)]
  }

  if (style.isAtomic) {
    return [prefix + style.cssClassName]
  }

  const classes: string[] = []
  for (const dep of style.dependencies) {
    classes.push(...collectAllCssClasses(dep, styles, new Set(visited), prefix))
  }
  return classes
}

/**
 * 生成 CssCls TypeScript interface
 */
export function generateCssClsInterface(styles: Map<string, CssStyleInfo>, prefix: string = ''): string {
  const lines: string[] = [
    '// Auto-generated by cssts',
    '// Do not edit manually',
    '',
    '/** CSS class 对象类型 */',
    'type CssClassObj = { readonly [key: string]: true }',
    '',
    'export interface CssCls {'
  ]

  for (const [name, info] of styles) {
    if (info.isAtomic) {
      const className = prefix + info.cssClassName
      lines.push(`  /** CSS class: '${className}' */`)
      lines.push(`  readonly ${name}: { readonly '${className}': true }`)
    } else {
      const deps = info.dependencies.join(', ')
      const allClasses = collectAllCssClasses(name, styles, new Set(), prefix)
      const classesType = allClasses.map(c => `'${c}': true`).join(', ')
      lines.push(`  /** Composed from: { ${deps} } */`)
      lines.push(`  readonly ${name}: { readonly ${classesType} }`)
    }
  }

  lines.push('}')
  lines.push('')
  lines.push('declare const CssCls: CssCls')
  lines.push('export default CssCls')

  return lines.join('\n')
}

/**
 * 生成 CssCls 实际值对象
 */
export function generateCssClsStyles(styles: Map<string, CssStyleInfo>, prefix: string = ''): string {
  const lines: string[] = [
    '// Auto-generated by cssts',
    '// Do not edit manually',
    '',
    'export const CssCls = {'
  ]

  const entries = Array.from(styles.entries())
  for (let i = 0; i < entries.length; i++) {
    const [name, info] = entries[i]
    const comma = i < entries.length - 1 ? ',' : ''

    if (info.isAtomic) {
      const className = prefix + info.cssClassName
      lines.push(`  ${name}: { '${className}': true }${comma}`)
    } else {
      const allClasses = collectAllCssClasses(name, styles, new Set(), prefix)
      const classesObj = allClasses.map(c => `'${c}': true`).join(', ')
      lines.push(`  ${name}: { ${classesObj} }${comma}`)
    }
  }

  lines.push('} as const')
  lines.push('')
  lines.push('export default CssCls')
  lines.push('')
  lines.push('// 类型定义')
  lines.push('export type CssClsKey = keyof typeof CssCls')
  lines.push('export type CssClsValue = typeof CssCls[CssClsKey]')

  return lines.join('\n')
}

/**
 * 分析使用的样式
 */
export function analyzeUsedClasses(
  usedStyles: string[],
  styles: Map<string, CssStyleInfo>,
  prefix: string = ''
): Set<string> {
  const result = new Set<string>()

  for (const styleName of usedStyles) {
    const classes = collectAllCssClasses(styleName, styles, new Set(), prefix)
    for (const cls of classes) {
      result.add(cls)
    }
  }

  return result
}
