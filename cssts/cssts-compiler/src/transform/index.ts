/**
 * CssTs 转换模块
 * 
 * 提供 .cssts 文件的完整转换功能
 */

import { CssTsParser } from '../parser/index.ts'
import { CssTsCstToAstUtils } from '../factory/index.ts'
import { registerSlimeCstToAstUtil } from 'slime-parser'
import { SlimeGenerator } from 'slime-generator'
import { ConfigLookup } from '../config/ConfigLookup'
import {
  getCssClassName,
  getCssProperty,
  getCssValue,
  camelToKebab,
  generateAtomCssRule,
  CSSTS_CONFIG
} from '../utils/cssClassName.ts'
import { generateAtomPropertyMap } from '../dts/atom-generator.ts'

/** CSS 属性值映射类型 */
type CssPropertyValueMap = Record<string, string | undefined>

// ==================== 类型定义 ====================

/**
 * 解析后的样式信息
 */
export interface ParsedStyleInfo {
  baseName: string    // 基础名称（原子类名或伪类基础类名）
  pseudos: string[]   // 伪类列表（普通原子类为空数组）
}

/**
 * 转换上下文（用于多文件聚合）
 */
export interface TransformContext {
  styles: Set<string>  // 存储所有样式名（原子类 + 伪类样式）
}

/**
 * 转换结果
 */
export interface TransformResult {
  code: string
  hasStyles: boolean
}

/**
 * 带 mapping 的转换结果（用于 LSP）
 */
export interface TransformResultWithMapping {
  code: string
  mapping: any[]
  hasStyles: boolean
}

// ==================== 样式名解析 ====================

/**
 * 解析样式名
 * 
 * @example
 * parseStyleName('displayFlex')              // { baseName: 'displayFlex', pseudos: [] }
 * parseStyleName('clickable$$hover$$active') // { baseName: 'clickable', pseudos: ['hover', 'active'] }
 */
export function parseStyleName(name: string): ParsedStyleInfo {
  const parts = name.split(CSSTS_CONFIG.PSEUDO_SEPARATOR)
  return {
    baseName: parts[0],
    pseudos: parts.slice(1)
  }
}

/**
 * 判断是否是伪类样式
 */
export function hasPseudos(name: string): boolean {
  return name.includes(CSSTS_CONFIG.PSEUDO_SEPARATOR)
}

// ==================== 核心转换 ====================

/**
 * 转换 .cssts 文件
 * 
 * @param code - 源代码
 * @param context - 转换上下文（用于写入 styles）
 * @returns 转换结果
 */
export function transformCssTs(code: string, context: TransformContext): TransformResult {
  const parser = new CssTsParser(code)
  const cst = parser.Program()  // 使用默认的 module 模式

  // 注意：cssTsCstToAst 是一个 live binding，当子类（如 OvsCstToSlimeAst）
  // 调用 registerCssTsCstToAst() 注册自己后，这里会自动使用新的实例
  // 这样 toProgram 和 getUsedAtoms 使用的是同一个实例
  const ast = CssTsCstToAstUtils.toFileAst(cst)

  // 收集使用的样式（原子类 + 伪类样式，直接写入 context）
  // 注：伪类样式（如 clickable$$hover$$active）在 CssTsCstToAst 中已自动收集
  const localUsedAtoms = CssTsCstToAstUtils.getUsedAtoms()

  for (const atom of localUsedAtoms) {
    context.styles.add(atom)
  }

  // 生成代码
  const tokens = parser.parsedTokens
  const result = SlimeGenerator.generator(ast, tokens)

  return {
    code: result.code,
    hasStyles: localUsedAtoms.size > 0
  }
}

/**
 * 转换 .cssts 文件（带 mapping，用于 LSP）
 * 
 * @param code - 源代码
 * @returns 转换结果（包含 code 和 mapping）
 */
export function transformCssTsWithMapping(code: string): TransformResultWithMapping {
  const parser = new CssTsParser(code)
  const cst = parser.Program()  // 使用默认的 module 模式
  // 使用单例，避免重复注册覆盖子类（如 OvsCstToSlimeAst）
  const ast = CssTsCstToAstUtils.toFileAst(cst)

  const localUsedAtoms = CssTsCstToAstUtils.getUsedAtoms()

  // 生成代码
  const tokens = parser.parsedTokens
  const result = SlimeGenerator.generator(ast, tokens)

  // 过滤无效的 mapping
  const mapping = result.mapping.filter(
    (m: any) => m.source && m.source.value && m.source.value !== '' && m.source.length > 0
  )

  return {
    code: result.code,
    mapping,
    hasStyles: localUsedAtoms.size > 0
  }
}

// ==================== CSS 生成 ====================

/**
 * 生成伪类 CSS 规则
 */
function generatePseudoCssRule(
  className: string,
  pseudo: string,
  pseudoConfig: CssPropertyValueMap,
  prefix: string = ''
): string {
  const fullClassName = prefix ? `${prefix}${className}` : className
  const props = Object.entries(pseudoConfig)
    .filter(([, val]) => val !== undefined)
    .map(([prop, val]) => `${camelToKebab(prop)}: ${val}`)
    .join('; ')
  return `.${fullClassName}:${pseudo} { ${props}; }`
}

/**
 * 生成所有 CSS（原子类 + 伪类样式）
 */
export function generateStylesCss(
  styles: Set<string>,
  prefix: string = ''
): string {
  const lines: string[] = ['/* Auto-generated by cssts-compiler */', '']

  // 分离原子类和伪类样式
  const atomStyles: string[] = []
  const pseudoStyles: Array<{ baseName: string; pseudos: string[] }> = []

  for (const name of styles) {
    const parsed = parseStyleName(name)
    if (parsed.pseudos.length > 0) {
      pseudoStyles.push(parsed)
    } else {
      atomStyles.push(name)
    }
  }

  // 1. 生成原子类 CSS（按属性分组）
  const grouped = new Map<string, string[]>()
  for (const atomName of atomStyles) {
    const rule = generateAtomCssRule(atomName, prefix)
    if (rule) {
      const property = getCssProperty(atomName) || 'other'
      if (!grouped.has(property)) grouped.set(property, [])
      grouped.get(property)!.push(rule)
    }
  }

  for (const property of [...grouped.keys()].sort()) {
    lines.push(`/* ${property} */`)
    lines.push(...grouped.get(property)!.sort())
    lines.push('')
  }

  // 2. 生成伪类 CSS（从 ConfigLookup 获取配置）
  const pseudoUtils = ConfigLookup.pseudoClassConfig
  if (pseudoUtils && pseudoStyles.length > 0) {
    lines.push('/* $$ Pseudo-class styles */')
    for (const { baseName, pseudos } of pseudoStyles) {
      const className = camelToKebab(baseName)
      for (const pseudo of pseudos) {
        const pseudoConfig = (pseudoUtils as Record<string, CssPropertyValueMap | undefined>)[pseudo]
        if (pseudoConfig) {
          const rule = generatePseudoCssRule(className, pseudo, pseudoConfig, prefix)
          lines.push(rule)
        }
      }
    }
    lines.push('')
  }

  return lines.join('\n')
}

/**
 * 生成 csstsAtom 虚拟模块内容
 * 
 * 格式：{ 原子类名: { CSS类名: CSS属性 | null } }
 * - 普通原子类：属性名（用于同属性替换）
 * - Group/伪类：null（不参与同属性替换）
 */
export function generateCsstsAtomModule(
  styles: Set<string>,
  prefix: string = ''
): string {
  const lines: string[] = [
    '// Auto-generated by cssts-compiler',
    '',
    'export const csstsAtom = {',
  ]

  // 获取原子类名 → CSS 属性的映射
  const atomPropertyMap = generateAtomPropertyMap()

  const entries: string[] = []
  const sortedStyles = [...styles].sort()

  for (const name of sortedStyles) {
    const parsed = parseStyleName(name)

    if (parsed.pseudos.length > 0) {
      // 伪类样式：使用 kebab-case 的基础类名，属性为 null
      const className = camelToKebab(parsed.baseName)
      const fullClassName = prefix ? `${prefix}${className}` : className
      entries.push(`  ${name}: { '${fullClassName}': null }`)
    } else {
      // 普通原子类：从映射获取属性
      const className = getCssClassName(name)
      const fullClassName = prefix ? `${prefix}${className}` : className
      const property = atomPropertyMap.get(name)

      if (property) {
        // 有属性：用于同属性替换
        entries.push(`  ${name}: { '${fullClassName}': '${property}' }`)
      } else {
        // 无属性（Group 或未知）：不参与替换
        entries.push(`  ${name}: { '${fullClassName}': null }`)
      }
    }
  }

  lines.push(entries.join(',\n'))
  lines.push('}', '', 'export default csstsAtom', '')
  return lines.join('\n')
}

